#!/bin/bash
#set -eux
#===================================================================================================
# loggingユーティリティ
#
# 概要
#   ${LOGLEVEL} に応じて stderr, ${PATH_LOG} にログメッセージを出力します。
#
# 依存
#   open usp tukubai
#
# 前提
#   システム設定を事前に読み込んでいること
#     ${EXITCODE_SUCCESS}, ${EXITCODE_WARN}, ${EXITCODE_ERROR} が事前に設定されていること
#     ${LOGLEVEL} が事前に設定されていること
#     ${PATH_LOG} が事前に設定されていること
#     log.mask が事前に定義されていること
#
#   パイプモードで利用する場合、必ず 標準入力に何らかの文字列が渡されること
#     ※cat - で受けるため、cdなど、出力のないコマンドからパイプでつなぐと予期せぬ動作が起こります。
#
# 定義リスト
#   log.add_indent
#   log.remove_indent
#   log.clear_indent
#   log.save_indent
#   log.restore_indent
#
#   log.trace
#   log.debug
#   log.info
#   log.warn
#   log.error
#
#   log.tee
#   log.split
#
#   log.is_trace_enabled
#   log.is_debug_enabled
#
#   log.rotatelog_by_day
#   log.rotatelog_by_day_first
#
#   log.script_start
#   log.script_end
#
#   log.func_start_trace
#   log.func_end_trace
#
#   log.sect_start_trace
#   log.sect_end_trace
#   log.sect_start_debug
#   log.sect_end_debug
#   log.sect_start_info
#   log.sect_end_info
#
#===================================================================================================
#---------------------------------------------------------------------------------------------------
# プロセス単位の環境変数 ※定数ですが、複数回sourceされることを考慮して変数として定義しています。
#---------------------------------------------------------------------------------------------------
LOGLEVEL=${LOGLEVEL:-${LOGLEVEL_INFO}}

# TODO フォーマットは、ここでの出力定義と、rotateでの正規表現の2箇所のメンテナンスが必要。
LOG__RAW_OUTPUT=${LOG__RAW_OUTPUT:-false}
LOG__FORMAT_DATE="+%Y-%m-%d"
LOG__FORMAT_TIMESTAMP="${LOG__FORMAT_DATE} %T"
LOG__INDENT_STR="--"
LOG__GREP_FORMAT="[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\} [0-9]\{2\}:[0-9]\{2\}:[0-9]\{2\} "

LOG__PREFIX_SCRIPT_START=${LOG__PREFIX_SCRIPT_START:-__START__ }
LOG__PREFIX_SCRIPT_END=${LOG__PREFIX_SCRIPT_END:-__END__ }
LOG__PREFIX_FUNC_START=${LOG__PREFIX_FUNC_START:-__START__ }
LOG__PREFIX_FUNC_END=${LOG__PREFIX_FUNC_END:-__END__ }
LOG__PREFIX_SECT_START=${LOG__PREFIX_SECT_START:-__START__ }
LOG__PREFIX_SECT_END=${LOG__PREFIX_SECT_END:-__END__ }

#---------------------------------------------------------------------------------------------------
# 起動元スクリプト単位の環境変数
#---------------------------------------------------------------------------------------------------
# 現在インデント深度
export LOG__INDENT_COUNT
# 一時保存インデント深度ファイル数
#   ※実ファイルは、スクリプト名 + PID毎に別管理しておき、各プロセス毎の restoreするインデント震度を保持しています。
export LOG__SAVED_INDENT_FILE_COUNT





#---------------------------------------------------------------------------------------------------
# インデント追加
#
# 引数
#   なし
#
#---------------------------------------------------------------------------------------------------
function log.add_indent() {
  LOG__INDENT_COUNT=$(( LOG__INDENT_COUNT + 1 ))
}
#---------------------------------------------------------------------------------------------------
# インデント削除
#
# 引数
#   ・1: インデント削除数 ※デフォルト:1
#
#---------------------------------------------------------------------------------------------------
function log.remove_indent() {
  local _count=${1:-1}
  LOG__INDENT_COUNT=$(( LOG__INDENT_COUNT - _count ))
}
#---------------------------------------------------------------------------------------------------
# インデントクリア
#---------------------------------------------------------------------------------------------------
function log.clear_indent() {
  LOG__INDENT_COUNT=0
}
#---------------------------------------------------------------------------------------------------
# インデント一時保存ディレクトリ ※PID毎に一意
#---------------------------------------------------------------------------------------------------
function private.log.get_stack_dir() {
  echo "/tmp/$(basename $0 .sh)_$$"
}
#---------------------------------------------------------------------------------------------------
# インデント一時保存
#---------------------------------------------------------------------------------------------------
function log.save_indent() {
  # 保存数のインクリメント
  LOG__SAVED_INDENT_FILE_COUNT=$(( LOG__SAVED_INDENT_FILE_COUNT + 1 ))

  # 保存ディレクトリの存在チェック
  if [ ! -d "$(private.log.get_stack_dir)" ]; then
    mkdir -p "$(private.log.get_stack_dir)"
  fi

  # 現在インデント深度をファイル保存
  echo ${LOG__INDENT_COUNT} > "$(private.log.get_stack_dir)/${LOG__SAVED_INDENT_FILE_COUNT}"

  # TRACE出力
  private.log.trace.echo_saved_indent_info
}
#---------------------------------------------------------------------------------------------------
# インデントリストア
#---------------------------------------------------------------------------------------------------
function log.restore_indent() {
  # インデント深度のリストア
  LOG__INDENT_COUNT=$(cat "$(private.log.get_stack_dir)/${LOG__SAVED_INDENT_FILE_COUNT}")

  # 保存ファイルの削除
  rm -f "$(private.log.get_stack_dir)/${LOG__SAVED_INDENT_FILE_COUNT}"

  # 保存ファイル数のデクリメント
  LOG__SAVED_INDENT_FILE_COUNT=$(( LOG__SAVED_INDENT_FILE_COUNT - 1 ))

  # ディレクトリ毎のファイル数確認
  local _stack_dir="$(private.log.get_stack_dir)"
  local _file_count="$(find ${_stack_dir} -mindepth 1 -maxdepth 1 -type f | wc -l)"
  if [ ${_file_count} -le 0 ]; then
    # 0以下の場合、保存ディレクトリ削除
    rm -fr "$(private.log.get_stack_dir)"
  fi

  # TRACE出力
  private.log.trace.echo_saved_indent_info
}
function private.log.trace.echo_saved_indent_info() {
  if [ "${LOGLEVEL}" != "${LOGLEVEL_TRACE}" ]; then
    return ${EXITCODE_SUCCESS}
  fi

#  local _stack_dir=$(private.log.get_stack_dir)
#  log.trace "-------------------------------------------------- TRACE-START --------------------------------------------------"
#  log.trace "- INVOKER                       : ${FUNCNAME[1]}"
#  log.trace "  - STACK_DIR                   : ${_stack_dir}"
#  log.trace "  - ls                          : $(test -d ${_stack_dir} && ls -l ${_stack_dir})"
#  log.trace "  - LOG__SAVED_INDENT_FILE_COUNT: ${LOG__SAVED_INDENT_FILE_COUNT}"
#  log.trace "  - LOG__INDENT_COUNT           : ${LOG__INDENT_COUNT}"
#  log.trace "-------------------------------------------------- TRACE-END   --------------------------------------------------"
}

#---------------------------------------------------------------------------------------------------
# インデント取得
#---------------------------------------------------------------------------------------------------
function log.get_indent() {
  echo "${LOG__INDENT_COUNT}"
}
#---------------------------------------------------------------------------------------------------
# インデント設定
#
# 引数
#   ・1: インデント数
#
#---------------------------------------------------------------------------------------------------
function log.set_indent() {
  local _count=$1
  if [ "${_count}" = "" ]; then
    log.clear_indent
    log.error "${FUNCNAME[0]}: インデント数が指定されていません。"                                 \
      "処理を見なおして下さい。呼び出し元:${FUNCNAME[1]}"                                          | log.tee
    exit ${EXITCODE_ERROR}
  fi
  LOG__INDENT_COUNT=${_count}
}



#---------------------------------------------------------------------------------------------------
# private.ログ標準出力
#
# 概要
#   ログフォーマットに従って、引数の文言を標準出力します。
#   標準出力されるのはマスキングされた結果です。
#
# 前提
#   ・なし
#
# 引数
#   ・1  : ログレベル
#   ・2〜: ログ出力文言
#
# 出力
#   標準出力
#
#---------------------------------------------------------------------------------------------------
function private.log.format() {
  local _log_level="$1"
  local _timestamp=$(date "${LOG__FORMAT_TIMESTAMP}")
  shift
  local _msg="$*"

  if [ "${LOG__RAW_OUTPUT}" = "true" ]; then
    # メッセージのみを出力
    echo "${_msg}"                                                                                 |
    log.mask
    return ${EXITCODE_SUCCESS}
  fi

  echo "${_msg}"                                                                                   |
  #--------------------------------------------------------------------------------------------------
  # レイアウト
  # TIMESTAMP LOG_LEVEL INDENT MESSAGE
  #--------------------------------------------------------------------------------------------------
  awk                                                                                              \
    -v _timestamp="${_timestamp}"                                                                  \
    -v _log_level="${_log_level}"                                                                  \
    -v LOG__INDENT_STR="${LOG__INDENT_STR}"                                                        \
    -v LOG__INDENT_COUNT=${LOG__INDENT_COUNT}                                                      \
    '
    {
      # 「TIMESTAMP LOG_LEVEL」の出力
      printf _timestamp" "_log_level

      # 「 INDENT」の出力
      for (i = 0; i < LOG__INDENT_COUNT; i++) {
        if ( i == 0) {
          printf " "
        }
        printf LOG__INDENT_STR
      }

      # 「MESSAGE + 改行」の出力
      print " "$0
    }
  '                                                                                                |
  log.mask
}



#---------------------------------------------------------------------------------------------------
# private.ログファイルチェック
#
# 概要
#   出力するログファイルの存在チェック、初期化処理です。
#
# 前提
#   ・PATH_LOG が定義されていること
#
# 引数
#   ・なし
#
# 出力
#   PATH_LOG ※空ファイル
#
#---------------------------------------------------------------------------------------------------
function private.log.check_file() {
  # 環境変数チェック
  if [ "${PATH_LOG}" = "" ]; then
    private.log.format "${LOGLEVEL_ERROR}" "ログファイルパス：PATH_LOG が設定されていません。" 1>&2
    return ${EXITCODE_ERROR}
  fi

  # ファイル存在チェック
  if [ ! -f "${PATH_LOG}" ]; then
    local _dir_log=$(dirname "${PATH_LOG}")
    if [ ! -d "${_dir_log}" ]; then
      mkdir -p "${_dir_log}"
      local _retcode=$?

      if [ ${_retcode} -ne ${EXITCODE_SUCCESS} ]; then
        private.log.format "${LOGLEVEL_ERROR}" "ログ出力ディレクトリが作成できません。対象：${_dir_log}" 1>&2
        return ${EXITCODE_ERROR}
      fi
    fi

    touch "${PATH_LOG}"
  fi

  return ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# private.ログ出力要否チェック
#
# 概要
#   引数のログレベルが、出力が必要か否かを判定します。
#
# 前提
#   ・LOGLEVEL が定義されていること
#
# 引数
#   ・1: 判定対象のログレベル
#
# 出力
#   なし
#
# 戻り値
#   出力が必要な場合: 0
#   出力が不要な場合: 3
#   判定できない場合: 6
#
#---------------------------------------------------------------------------------------------------
function private.log.is_write() {
  local _trg_log_lebel="$1"

  #-------------------------------------------------------------------------------------------------
  # 前提チェック
  #-------------------------------------------------------------------------------------------------
  # ログレベル
  if [ "${LOGLEVEL}" = "" ]; then
    private.log.format "${LOGLEVEL_ERROR}" "出力ログレベル：LOGLEVEL が設定されていません。" 1>&2
    return ${EXITCODE_ERROR}
  fi

  #-------------------------------------------------------------------------------------------------
  # 引数チェック
  #-------------------------------------------------------------------------------------------------
  if [ "${_trg_log_lebel}" != "${LOGLEVEL_TRACE}" ] && \
     [ "${_trg_log_lebel}" != "${LOGLEVEL_DEBUG}" ] && \
     [ "${_trg_log_lebel}" != "${LOGLEVEL_INFO}"  ] && \
     [ "${_trg_log_lebel}" != "${LOGLEVEL_WARN}"  ] && \
     [ "${_trg_log_lebel}" != "${LOGLEVEL_ERROR}" ] ; then
    private.log.format "${LOGLEVEL_ERROR}" "ログレベル：「${_trg_log_lebel}」は想定外の値です。" 1>&2
    return ${EXITCODE_ERROR}
  fi

  if [ "${LOGLEVEL}" = "${LOGLEVEL_DEBUG}" ]; then
    # DEBUG以上のログレベルを出力
    if [ "${_trg_log_lebel}" = "${LOGLEVEL_TRACE}" ]; then
      return ${EXITCODE_WARN}
    fi

  elif [ "${LOGLEVEL}" = "${LOGLEVEL_INFO}" ]; then
    # INFO以上のログレベルを出力
    if [ "${_trg_log_lebel}" = "${LOGLEVEL_TRACE}" ] || \
       [ "${_trg_log_lebel}" = "${LOGLEVEL_DEBUG}" ] ; then
      return ${EXITCODE_WARN}
    fi

  elif [ "${LOGLEVEL}" = "${LOGLEVEL_WARN}" ]; then
    # WARN以上のログレベルを出力
    if [ "${_trg_log_lebel}" = "${LOGLEVEL_TRACE}" ] || \
       [ "${_trg_log_lebel}" = "${LOGLEVEL_DEBUG}" ] || \
       [ "${_trg_log_lebel}" = "${LOGLEVEL_INFO}"  ] ; then
      return ${EXITCODE_WARN}
    fi

  elif [ "${LOGLEVEL}" = "${LOGLEVEL_ERROR}" ]; then
    # ERROR以上のログレベルを出力
    if [ "${_trg_log_lebel}" = "${LOGLEVEL_TRACE}" ] || \
       [ "${_trg_log_lebel}" = "${LOGLEVEL_DEBUG}" ] || \
       [ "${_trg_log_lebel}" = "${LOGLEVEL_INFO}"  ] || \
       [ "${_trg_log_lebel}" = "${LOGLEVEL_WARN}"  ] ; then
      return ${EXITCODE_WARN}
    fi
  fi

  return ${EXITCODE_SUCCESS}
}





#---------------------------------------------------------------------------------------------------
# private.ログコンソール出力
#
# 概要
#   引数の文言 or パイプ経由の標準入力 を、コンソールにログフォーマットで出力します。
#
# 前提
#   ・LOGLEVEL が定義されていること
#   ・PATH_LOG が定義されていること
#
# 引数
#   ・1  : 出力ログレベル
#   ・2〜: 出力文言 ※パイプの場合は不要
#
# 出力
#   標準出力/標準エラー
#
# 戻り値
#   出力に成功した場合: 0
#   出力に失敗した場合: 6
#
#---------------------------------------------------------------------------------------------------
function private.log.console() {
  local _trg_log_level="$1"
  shift

  #-------------------------------------------------------------------------------------------------
  # 出力判定
  #-------------------------------------------------------------------------------------------------
  private.log.is_write "${_trg_log_level}"
  local _retcode=$?
  if [ ${_retcode} -eq ${EXITCODE_ERROR} ]; then
    # 判定できない場合、エラー終了
    return ${EXITCODE_ERROR}
  fi

  #-------------------------------------------------------------------------------------------------
  # パイプ判断
  #-------------------------------------------------------------------------------------------------
  if [ -p /dev/stdin ] && [ $# -eq 0 ]; then
    # パイプの場合
    if [ ${_retcode} -eq ${EXITCODE_WARN} ]; then
      # 出力が不要な場合、ここで終了
      cat - >/dev/null 2>&1
      return ${EXITCODE_SUCCESS}
    fi

    while IFS= read -r _cur_row; do
        private.log.format "${_trg_log_level}" "${_cur_row}" 1>&2
    done < <(cat -)

  else
    # 引数指定の場合
    if [ ${_retcode} -eq ${EXITCODE_WARN} ]; then
      # 出力が不要な場合、ここで終了
      return ${EXITCODE_SUCCESS}
    fi

    private.log.format "${_trg_log_level}" "$@" 1>&2
  fi

  return ${EXITCODE_SUCCESS}
}
#---------------------------------------------------------------------------------------------------
# traceログ コンソール出力
#---------------------------------------------------------------------------------------------------
function log.trace() {
  local _trg_log_level="${LOGLEVEL_TRACE}"

  if [ -p /dev/stdin ] && [ $# -eq 0 ]; then
    cat - | private.log.console "${_trg_log_level}"
  else
    local _before_IFS=$IFS
    IFS=" $'\n'$'\t'"
    private.log.console "${_trg_log_level}" "$@"
    IFS=${_before_IFS}
  fi

  return ${EXITCODE_SUCCESS}
}
#---------------------------------------------------------------------------------------------------
# debugログ コンソール出力
#---------------------------------------------------------------------------------------------------
function log.debug() {
  local _trg_log_level="${LOGLEVEL_DEBUG}"

  if [ -p /dev/stdin ] && [ $# -eq 0 ]; then
    cat - | private.log.console "${_trg_log_level}"
  else
    local _before_IFS=$IFS
    IFS=" $'\n'$'\t'"
    private.log.console "${_trg_log_level}" "$@"
    IFS=${_before_IFS}
  fi

  return ${EXITCODE_SUCCESS}
}
#---------------------------------------------------------------------------------------------------
# infoログ コンソール出力
#---------------------------------------------------------------------------------------------------
function log.info() {
  local _trg_log_level="${LOGLEVEL_INFO}"

  if [ -p /dev/stdin ] && [ $# -eq 0 ]; then
    cat - | private.log.console "${_trg_log_level}"
  else
    local _before_IFS=$IFS
    IFS=" $'\n'$'\t'"
    private.log.console "${_trg_log_level}" "$@"
    IFS=${_before_IFS}
  fi

  return ${EXITCODE_SUCCESS}
}
#---------------------------------------------------------------------------------------------------
# warnログ コンソール出力
#---------------------------------------------------------------------------------------------------
function log.warn() {
  local _trg_log_level="${LOGLEVEL_WARN}"

  if [ -p /dev/stdin ] && [ $# -eq 0 ]; then
    cat - | private.log.console "${_trg_log_level}"
  else
    local _before_IFS=$IFS
    IFS=" $'\n'$'\t'"
    private.log.console "${_trg_log_level}" "$@"
    IFS=${_before_IFS}
  fi

  return ${EXITCODE_SUCCESS}
}
#---------------------------------------------------------------------------------------------------
# errorログ コンソール出力
#---------------------------------------------------------------------------------------------------
function log.error() {
  local _trg_log_level="${LOGLEVEL_ERROR}"

  if [ -p /dev/stdin ] && [ $# -eq 0 ]; then
    cat - | private.log.console "${_trg_log_level}"
  else
    local _before_IFS=$IFS
    IFS=" $'\n'$'\t'"
    private.log.console "${_trg_log_level}" "$@"
    IFS=${_before_IFS}
  fi

  return ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# 概要
#   パイプで渡された標準出力を、PATH_LOGに追記して、標準エラー出力します。
#   ※バウンダリスクリプトなどで、標準エラー出力されたログをファイルにteeする状況を想定しています。
#
#   stdin ----> stdout   ----> stderr
#          |--> PATH_LOG
#
# 引数
#   なし
#
# 出力
#   なし
#
# サンプル
#   command 2>&1 | log.tee
#
#---------------------------------------------------------------------------------------------------
function log.tee() {
  local _dir_log="$(dirname ${PATH_LOG})"
  if [[ ! -d "${_dir_log}" ]]; then mkdir -p "${_dir_log}"; fi
  cat - | tee -a ${PATH_LOG} 1>&2
}



#---------------------------------------------------------------------------------------------------
# 概要
#   パイプで渡された標準出力を標準出力と標準エラーに分岐します。
#   ※標準出力で実行結果を返す機能で、ログにも出力したい状況を想定しています。
#
#   stdin ----> stdout
#          |--> stderr
#
# 引数
#   なし
#
# 出力
#   なし
#
# サンプル
#   command | log.split
#
#---------------------------------------------------------------------------------------------------
function log.split() {
  cat - | tee -a /dev/stderr
}



function log.is_trace_enabled() {
  if [ "${LOGLEVEL}" = "${LOGLEVEL_TRACE}" ]; then
    echo "true"
  else
    echo "false"
  fi
  return ${EXITCODE_SUCCESS}
}



function log.is_debug_enabled() {
  if [ "${LOGLEVEL}" = "${LOGLEVEL_TRACE}" ] ||
     [ "${LOGLEVEL}" = "${LOGLEVEL_DEBUG}" ]; then
    echo "true"
  else
    echo "false"
  fi
  return ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# 概要
#   ログローテーション（日次）
#
# 引数
#   なし
#
# 出力
#   ${PATH_LOG}.${日付}
#
#---------------------------------------------------------------------------------------------------
function log.rotatelog_by_day() {
  #-------------------------------------------------------------------------------------------------
  # 事前処理
  #-------------------------------------------------------------------------------------------------
  # ログファイルチェック
  private.log.check_file
  if [ ${_retcode} -ne ${EXITCODE_SUCCESS} ]; then return ${_retcode}; fi

  #-------------------------------------------------------------------------------------------------
  # 本処理
  #-------------------------------------------------------------------------------------------------
  # 当日
  local _cur_date=$(date ${LOG__FORMAT_DATE})

  # 最終行の日付
  local _last_date=$(grep "${LOG__GREP_FORMAT}" "${PATH_LOG}" | tail -n 1 | cut -d " " -f 1)
  if [ "${_last_date}x" = "x" ]; then
    return ${EXITCODE_SUCCESS}
  fi

  # 最終行の日付が当日と一致するか確認
  if [ "${_last_date}" != "${_cur_date}" ]; then

    # 一致しない場合、ローテーション
    local _path_output="${PATH_LOG}.${_last_date//\//}"

    # ローテーション先ファイルが存在する場合、現在時刻でリネーム
    if [ -f "${_path_output}" ]; then
      mv "${_path_output}" "${_path_output}.$(date '+%Y%m%d%H%M%S')"
    fi

    # コピー
    cp -p "${PATH_LOG}" "${_path_output}"
    _retcode=$?
    if [ ${_retcode} -ne 0 ]; then
      local _filename_output="$(basename ${_path_output})"
      private.log.format "${LOGLEVEL_ERROR}" \
        "ログローテーション（日次）に失敗しました。${PATH_LOG} を ${_filename_output} にコピーできません。" 1>&2
      return ${EXITCODE_ERROR}
    fi

    # 本体を空に置き換え
    cp /dev/null ${PATH_LOG}
    _retcode=$?
    if [ ${_retcode} -ne 0 ]; then
      private.log.format "${LOGLEVEL_ERROR}" \
        "ログローテーション（日次）に失敗しました。${PATH_LOG} を 空ファイル に置き換えできません。" 1>&2
      return ${EXITCODE_ERROR}
    fi
  fi
  #-------------------------------------------------------------------------------------------------
  # 事後処理
  #-------------------------------------------------------------------------------------------------
  return ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# 概要
#   ログローテーション（日次） ※先頭行で判断
#
# 引数
#   なし
#
# 出力
#   ${PATH_LOG}.${日付}
#
#---------------------------------------------------------------------------------------------------
function log.rotatelog_by_day_first() {
  #-------------------------------------------------------------------------------------------------
  # 事前処理
  #-------------------------------------------------------------------------------------------------
  # ログファイルチェック
  private.log.check_file
  local _retcode=$?
  if [ ${_retcode} -ne ${EXITCODE_SUCCESS} ]; then return ${_retcode}; fi

  #-------------------------------------------------------------------------------------------------
  # 本処理
  #-------------------------------------------------------------------------------------------------
  # 当日
  local _cur_date=$(date ${LOG__FORMAT_DATE})

  # 先頭行の日付
  local _first_date=$(grep "${LOG__GREP_FORMAT}" "${PATH_LOG}" | head -n 1 | cut -d " " -f 1)
  if [ "${_first_date}x" = "x" ]; then
    return ${EXITCODE_SUCCESS}
  fi

  # 先頭行の日付が当日と一致するか確認
  if [ "${_first_date}" != "${_cur_date}" ]; then

    # 一致しない場合、ローテーション
    local _path_output="${PATH_LOG}.${_first_date//\//}"

    # ローテーション先ファイルが存在する場合、現在時刻でリネーム
    if [ -f "${_path_output}" ]; then
      mv "${_path_output}" "${_path_output}.$(date '+%Y%m%d%H%M%S')"
    fi

    # コピー
    cp -p "${PATH_LOG}" "${_path_output}"
    _retcode=$?
    if [ ${_retcode} -ne 0 ]; then
      local _filename_output="$(basename ${_path_output})"
      private.log.format "${LOGLEVEL_ERROR}" \
        "ログローテーション（日次）に失敗しました。${PATH_LOG} を ${_filename_output} にコピーできません。" 1>&2
      return ${EXITCODE_ERROR}
    fi

    # 本体を空に置き換え
    cp /dev/null ${PATH_LOG}
    _retcode=$?
    if [ ${_retcode} -ne 0 ]; then
      private.log.format "${LOGLEVEL_ERROR}" \
        "ログローテーション（日次）に失敗しました。${PATH_LOG} を 空ファイル に置き換えできません。" 1>&2
      return ${EXITCODE_ERROR}
    fi
  fi

  #-------------------------------------------------------------------------------------------------
  # 事後処理
  #-------------------------------------------------------------------------------------------------
  return ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# 概要
#   スクリプト開始ログ
#
# 引数
#   1 : スクリプトパス
#   2~: スクリプト引数リスト
#
# 設定
#   LOG__PREFIX_SCRIPT_START
#
# 出力
#   なし
#
# サンプル
#   log.script_start "$0" "$*"
#     -> yyyy-mm-dd hh:mm:ss INFO  __START__ your_script_name.sh ARG1 ARG2
#
#---------------------------------------------------------------------------------------------------
function log.script_start() {
  local _script_path="$1"
  shift
  local _args="$*"

  local _script_name=$(basename "${_script_path}")

  log.save_indent
  log.info "${LOG__PREFIX_SCRIPT_START}${_script_name} ${_args}"                                   | log.tee
  log.add_indent

  # 処理時間計測start
  processing_time.start "${_script_path}_$$"
  return ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# 概要
#   スクリプト終了ログ
#
# 引数
#   1: スクリプトパス
#   2: 終了コード
#   3: 終了メッセージ
#
# 設定
#   LOG__PREFIX_SCRIPT_END
#
# 出力
#   なし
#
# サンプル
#   log.script_end "$0" "0" "NORMAL END."
#     -> yyyy-mm-dd hh:mm:ss INFO  NORMAL END.
#     -> yyyy-mm-dd hh:mm:ss INFO  exit_code: 0
#     -> yyyy-mm-dd hh:mm:ss INFO  __END__ your_script_name.sh
#
#   log.script_end "$0" "3" "PROCESS END WITH WARNING."
#     -> yyyy-mm-dd hh:mm:ss WARN  PROCESS END WITH WARNING.
#     -> yyyy-mm-dd hh:mm:ss WARN  exit_code: 3
#     -> yyyy-mm-dd hh:mm:ss WARN  __END__ your_script_name.sh
#
#   log.script_end "$0" "6" "error occured in SOME_PROCESS."
#     -> yyyy-mm-dd hh:mm:ss ERROR error occured in SOME_PROCESS.
#     -> yyyy-mm-dd hh:mm:ss ERROR exit_code: 6
#     -> yyyy-mm-dd hh:mm:ss ERROR __END__ your_script_name.sh
#
#---------------------------------------------------------------------------------------------------
function log.script_end() {
  local _script_path="$1"
  local _exit_code="$2"
  local _exit_message="$3"

  local _script_name=$(basename "${_script_path}")

  # 処理時間計算
  local _processing_time=$(processing_time.calc "${_script_path}_$$")
  local _msg_processing_time="[processing_time=${_processing_time}]"
  local _msg="${LOG__PREFIX_SCRIPT_END}${_script_name} ${_msg_processing_time}"

  log.restore_indent
  if [ ${_exit_code} -eq ${EXITCODE_SUCCESS} ]; then
    if [ "${_exit_message}" != "" ]; then log.info "${_exit_message}" | log.tee; fi
    log.info "${_msg}" | log.tee

  elif [ ${_exit_code} -le ${EXITCODE_WARN} ]; then
    if [ "${_exit_message}" != "" ]; then log.warn "${_exit_message}" | log.tee; fi
    log.warn "${_msg}" | log.tee

  else
    if [ "${_exit_message}" != "" ]; then log.error "${_exit_message}" | log.tee; fi
    log.error "${_msg}" | log.tee
  fi

  return ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# 概要
#   関数開始ログ
#
# 引数
#   1~: スクリプト引数リスト
#
# 設定
#   LOG__PREFIX_FUNC_START
#
# 出力
#   なし
#
# サンプル
#   log.func_start_trace "$*"
#     -> yyyy-mm-dd hh:mm:ss INFO  -- __START__ your_func_name ARG1 ARG2
#
#---------------------------------------------------------------------------------------------------
function log.func_start_trace() {
  if [[ "$(log.is_trace_enabled)" != "true" ]]; then return ${EXITCODE_SUCCESS}; fi

  local _invoker_name="${FUNCNAME[1]}"
  local _args="$*"

  log.save_indent
  log.trace "${LOG__PREFIX_FUNC_START}${_invoker_name} ${_args}"
  log.add_indent

  # 処理時間計測start
  processing_time.start "${_invoker_name}_$$"
  return ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# 概要
#   関数終了ログ
#
# 引数
#   1: 終了コード
#
# 設定
#   LOG__PREFIX_FUNC_END
#
# 出力
#   なし
#
# サンプル
#   log.func_end_trace "0"
#     -> yyyy-mm-dd hh:mm:ss INFO  -- __END__ your_func_name
#
#   log.func_end_trace "3"
#     -> yyyy-mm-dd hh:mm:ss WARN  -- __END__ your_func_name
#
#   log.func_end_trace "6"
#     -> yyyy-mm-dd hh:mm:ss ERROR -- __END__ your_func_name
#
#---------------------------------------------------------------------------------------------------
function log.func_end_trace() {
  if [[ "$(log.is_trace_enabled)" != "true" ]]; then return ${EXITCODE_SUCCESS}; fi

  local _invoker_name="${FUNCNAME[1]}"
  local _exit_code="$1"

  # 処理時間計算
  local _processing_time=$(processing_time.calc "${_invoker_name}_$$")
  local _msg_processing_time="[processing_time=${_processing_time}]"
  local _msg="${LOG__PREFIX_FUNC_END}${_invoker_name} ${_msg_processing_time}"

  log.restore_indent
  if [ ${_exit_code} -eq ${EXITCODE_SUCCESS} ]; then
    log.trace "${_msg}"
  elif [ ${_exit_code} -le ${EXITCODE_WARN} ]; then
    log.warn "${_msg}"
  else
    log.error "${_msg}"
  fi

  return ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# 概要
#   セクション開始ログ
#
# 引数
#   1: セクション名
#
# 設定
#   LOG__PREFIX_SETC_START
#
# 出力
#   なし
#
# サンプル
#   log.sect_start_trace "your_section_name"
#     -> yyyy-mm-dd hh:mm:ss INFO  -- __START__ your_section_name
#
#---------------------------------------------------------------------------------------------------
function log.sect_start_trace() {
  private.log.sect_start "${LOGLEVEL_TRACE}" "$@"
  return $?
}



#---------------------------------------------------------------------------------------------------
# 概要
#   セクション終了ログ
#
# 引数
#   1: セクション名
#   2: 終了コード
#
# 設定
#   LOG__PREFIX_SECT_END
#
# 出力
#   なし
#
# サンプル
#   log.func_end_trace "0"
#     -> yyyy-mm-dd hh:mm:ss INFO  -- __END__ your_func_name
#
#   log.func_end_trace "3"
#     -> yyyy-mm-dd hh:mm:ss WARN  -- __END__ your_func_name
#
#   log.func_end_trace "6"
#     -> yyyy-mm-dd hh:mm:ss ERROR -- __END__ your_func_name
#
#---------------------------------------------------------------------------------------------------
function log.sect_end_trace() {
  private.log.sect_end "${LOGLEVEL_TRACE}" "$@"
  return $?
}



function log.sect_start_debug() {
  private.log.sect_start "${LOGLEVEL_DEBUG}" "$@"
  return $?
}
function log.sect_end_debug() {
  private.log.sect_end "${LOGLEVEL_DEBUG}" "$@"
  return $?
}



function log.sect_start_info() {
  private.log.sect_start "${LOGLEVEL_INFO}" "$@"
  return $?
}
function log.sect_end_info() {
  private.log.sect_end "${LOGLEVEL_INFO}" "$@"
  return $?
}



function private.log.sect_start() {
  local _log_level="$1"
  local _section_name="$2"

  if [[ "${_log_level}" = "${LOGLEVEL_TRACE}" ]] && [[ "$(log.is_trace_enabled)" != "true" ]]; then return ${EXITCODE_SUCCESS}; fi
  if [[ "${_log_level}" = "${LOGLEVEL_DEBUG}" ]] && [[ "$(log.is_debug_enabled)" != "true" ]]; then return ${EXITCODE_SUCCESS}; fi

  local _msg="${LOG__PREFIX_SECT_START}${_section_name}"

  log.save_indent
  if [[ "${_log_level}" = "${LOGLEVEL_TRACE}" ]]; then log.trace "${_msg}"; fi
  if [[ "${_log_level}" = "${LOGLEVEL_DEBUG}" ]]; then log.debug "${_msg}"; fi
  if [[ "${_log_level}" = "${LOGLEVEL_INFO}" ]]; then  log.info  "${_msg}"; fi
  log.add_indent

  # 処理時間計測start
  processing_time.start "${_section_name}_$$"

  return ${EXITCODE_SUCCESS}
}
function private.log.sect_end() {
  local _log_level="$1"
  local _section_name="$2"
  local _exit_code="$3"

  if [[ "${_log_level}" = "${LOGLEVEL_TRACE}" ]] && [[ "$(log.is_trace_enabled)" != "true" ]]; then return ${EXITCODE_SUCCESS}; fi
  if [[ "${_log_level}" = "${LOGLEVEL_DEBUG}" ]] && [[ "$(log.is_debug_enabled)" != "true" ]]; then return ${EXITCODE_SUCCESS}; fi

  # 処理時間計算
  local _processing_time=$(processing_time.calc "${_section_name}_$$")
  local _msg_processing_time="[processing_time=${_processing_time}]"
  local _msg="${LOG__PREFIX_SECT_END}${_section_name} ${_msg_processing_time}"

  log.restore_indent
  if [ ${_exit_code} -eq ${EXITCODE_SUCCESS} ]; then
    if [[ "${_log_level}" = "${LOGLEVEL_TRACE}" ]]; then log.trace "${_msg}"; fi
    if [[ "${_log_level}" = "${LOGLEVEL_DEBUG}" ]]; then log.debug "${_msg}"; fi
    if [[ "${_log_level}" = "${LOGLEVEL_INFO}" ]]; then  log.info  "${_msg}"; fi
  elif [ ${_exit_code} -le ${EXITCODE_WARN} ]; then
    log.warn "${_msg}"
  else
    log.error "${_msg}"
  fi

  return ${EXITCODE_SUCCESS}
}
