#!/bin/bash
#==================================================================================================
#
# bash共通関数定義
# ※_で始まるfunctionは、パイプでの呼出しだけを想定しています。
#
# 依存
#   open usp tukubai
#   Parsrs
#
# 定義リスト
#   is_mac
#   is_linux
#   is_cygwin
#   _trim
#   _ltrim
#   _rtrim
#   _sp_multi2single
#   _unquote
#   _except_comment_row
#   _except_empty_row
#   gen_ssh_server_key
#   get_ip
#   _urlencode
#   _urldecode
#   get_ext
#   gen_encrypt_key
#   _encrypt
#   _decrypt
#   is_errorexit_on
#   is_nounset_on
#   is_xtrace_on
#   is_setoption_on
#   yaml2properties
#   export_yaml
#   apply_dynamic_env
#   processing_time.start
#   processing_time.end
#   timestamp_to_iso
#
#==================================================================================================
#--------------------------------------------------------------------------------------------------
# 実行OS判定
#--------------------------------------------------------------------------------------------------
function is_mac() {
  if [[ "$(uname)" = 'Darwin' ]]; then
    echo "true"
  else
    echo "false"
  fi
  return 0
}

function is_linux() {
  local _uname=$(awk -v "uname=$(uname -s)" 'BEGIN { print substr(uname, 1, 5) }')
  if [[ "${_uname}" = 'Linux' ]]; then
    echo "true"
  else
    echo "false"
  fi
  return 0
}

function is_cygwin() {
  local _uname=$(awk -v "uname=$(uname -s)" 'BEGIN { print substr(uname, 1, 10) }')
  if [[ "${_uname}" = 'MINGW32_NT' ]]; then
    echo "true"
  else
    echo "false"
  fi
  return 0
}


#--------------------------------------------------------------------------------------------------
# 文字列操作
#--------------------------------------------------------------------------------------------------
function _trim() {
  cat -                                                                                            | # 標準入力から
  sed -e "s|^  *||g"                                                                               | # leftトリム
  sed -e "s|  *$||g"                                                                                 # rightトリム
  return 0
}

function _ltrim() {
  cat -                                                                                            | # 標準入力から
  sed -e "s|^  *||g"                                                                                 # leftトリム
  return 0
}

function _rtrim() {
  cat -                                                                                            | # 標準入力から
  sed -e "s|  *$||g"                                                                                 # rightトリム
  return 0
}

function _sp_multi2single() {
  cat -                                                                                            | # 標準入力から
  sed -E "s| +| |g"                                                                                  # 複数スペースを単一に置換
  return 0
}

function _unquote() {
  cat -                                                                                            | # 標準入力から
  sed -e "s|^'||" -e "s|'$||"                                                                      | # シングルクォートを除去
  sed -e 's|^"||' -e 's|"$||'                                                                        # ダブルクォートを除去
  return 0
}


#--------------------------------------------------------------------------------------------------
# 行操作
#--------------------------------------------------------------------------------------------------
function _except_comment_row() {
  cat -                                                                                            | # 標準入力から
  grep -v '^\s*#'                                                                                    # コメント行を除外
  return 0
}

function _except_empty_row() {
  cat -                                                                                            | # 標準入力から
  grep -v '^\s*$'                                                                                    # 空行を除外
  return 0
}


#--------------------------------------------------------------------------------------------------
# SSH
#--------------------------------------------------------------------------------------------------
function gen_ssh_server_key() {
  local _USAGE="usage: ${FUNCNAME[0]} IP"
  local _PATH_KNOWN_HOSTS=~/.ssh/known_hosts

  # 引数チェック
  if [[ $# -ne 1 ]]; then
    echo "${_USAGE}" >&2
    return 1
  fi

  local _ip="$1"
  local _ret_code=0

  # キーの存在チェック
  grep "${_ip}" "${_PATH_KNOWN_HOSTS}" > /dev/null 2>&1
  _ret_code=$?
  if [ ${_ret_code} -eq 0 ]; then
    echo "SSH server key for ${_ip} is already exists." >&2
    return 0
  fi

  # サーバキー削除
  ssh-keygen -R ${_ip} > /dev/null 2>&1
  _ret_code=$?
  if [ ${_ret_code} -ne 0 ]; then
    echo "failed to delete SSH server key for ${_ip} . cmd: ssh-keygen -R ${_ip}, retcode: ${_ret_code}" >&2
    return 1
  fi

  # サーバキー追加
  ssh-keyscan ${_ip} >> ${_PATH_KNOWN_HOSTS} 2> /dev/null
  _ret_code=$?
  if [ ${_ret_code} -ne 0 ]; then
    echo "failed to add SSH server key for ${_ip}. cmd: ssh-keyscan ${_ip} >> ${_PATH_KNOWN_HOSTS}, retcode: ${_ret_code}" >&2
    return 1
  fi

  echo "SSH server key for ${_ip} was added." >&2
  return 0
}


#--------------------------------------------------------------------------------------------------
# 自ホストIPアドレス取得
#--------------------------------------------------------------------------------------------------
function get_ip() {
  # 自IPを標準出力
  LANG=C /sbin/ifconfig                                                                            |
  grep 'inet '                                                                                     |
  grep -v 127.0.0.1                                                                                |
  head -n 1                                                                                        |
  awk '{print $2}'                                                                                 |
  cut -d ':' -f 2
  return 0
}


#--------------------------------------------------------------------------------------------------
# URLエンコード・デコード
#--------------------------------------------------------------------------------------------------
function _urlencode() {
  local _lf='\%0A'

  cat -                                                                                            | # 標準出力から
  python -c 'import sys, urllib ; print urllib.quote(sys.stdin.read());'                           | # URLエンコード
  sed "s|${_lf}$||g"                                                                                 # 末尾に改行コードが付与されるので除外

  return 0
}

function _urldecode() {
  cat -                                                                                            | # 標準出力から
  python -c 'import sys, urllib ; print urllib.unquote(sys.stdin.read());'

  return 0
}


#------------------------------------------------------------------------------
# 拡張子取得
#
# 引数
#   $1: 対象ファイルパス
#------------------------------------------------------------------------------
function get_ext() {
  local _path="$1"
  local _ext="${_path##*.}"

  # 変数展開結果を確認
  if [[ "${_ext}" = "gz" ]]; then
    # gzの場合、2重拡張子を確認 ※tar.gzのみ対応
    if [[ "$(basename ${_path} .tar.gz)" != "$(basename ${_path})" ]]; then
      _ext="tar.gz"
    fi

  elif [[ "${_ext}" = "${_path}" ]]; then
    # pathそのままの場合、拡張子なし
    _ext=""
  fi

  echo "${_ext}"
  return ${EXITCODE_SUCCESS}
}


#--------------------------------------------------------------------------------------------------
# 暗号化・復号化
#--------------------------------------------------------------------------------------------------
function gen_encrypt_key() {
  # 引数チェック
  if [[ $# -ne 2 ]]; then
    echo "usage: ${FUNCNAME[0]} PATH_ENCRYPT_KEY PATH_DECRYPT_KEY" >&2
    return 1
  fi

  local _path_encrypt_key="$1"
  local _path_decrypt_key="$2"

  # 鍵作成
  echo "openssl req -x509 -nodes -newkey rsa:2048 -keyout \"${_path_decrypt_key}\" -out \"${_path_encrypt_key}\" -subj '/'"
  openssl req -x509 -nodes -newkey rsa:2048 -keyout "${_path_decrypt_key}" -out "${_path_encrypt_key}" -subj '/'
  return $?
}

function _encrypt() {
  # 引数チェック
  if [[ $# -ne 1 ]]; then
    echo "usage: ${FUNCNAME[0]} PATH_ENCRYPT_KEY" >&2
    return 1
  fi

  local _path_encrypt_key="$1"
  if [[ ! -f "${_path_encrypt_key}" ]]; then
    echo "${_path_encrypt_key} is not exist." >&2
    return 1
  fi

  # 暗号化
  cat -                                                                                            | # 標準入力（平文）を
  openssl smime -encrypt -aes256 -binary -outform PEM "${_path_encrypt_key}"                          # 暗号化キーで暗号化
  return 0
}

function _decrypt() {
  # 引数チェック
  if [[ $# -ne 1 ]]; then
    echo "usage: ${FUNCNAME[0]} PATH_DECRYPT_KEY" >&2
    return 1
  fi

  local _path_decrypt_key="$1"
  if [[ ! -f "${_path_decrypt_key}" ]]; then
    echo "${_path_decrypt_key} is not exist." >&2
    return 1
  fi

  # 復号化
  cat -                                                                                            | # 標準入力（暗号化文字列）を
  openssl smime -decrypt -binary -inform PEM -inkey "${_path_decrypt_key}"                            # 復号化キーで復号化
  return 0
}


#--------------------------------------------------------------------------------------------------
# setオプション判定
#--------------------------------------------------------------------------------------------------
function is_errorexit_on() {
  is_setoption_on "errexit"
}
function is_nounset_on() {
  is_setoption_on "nounset"
}
function is_xtrace_on() {
  is_setoption_on "xtrace"
}
function is_setoption_on() {
  local _target="$1"
  set -o                                                                                           |
  grep "${_target}"                                                                                |
  tr '\t' ' '                                                                                      |
  _sp_multi2single                                                                                 |
  cut -d ' ' -f 2                                                                                  |
  sed -e 's|on|true|'                                                                              |
  sed -e 's|off|false|'
}
#
# SAMPLE
#
# local _before_set_errorexit=$(is_errorexit_on)
# local _before_set_nounset=$(is_nounset_on)
# local _before_set_xtrace=$(is_xtrace_on)
# set +eux
#
# 任意の処理...
#
# if [[ "${_before_set_errorexit}" = "true" ]]; then set -e; fi
# if [[ "${_before_set_nounset}"   = "true" ]]; then set -u; fi
# if [[ "${_before_set_xtrace}"    = "true" ]]; then set -x; fi



#--------------------------------------------------------------------------------------------------
# yamlファイル -> properties変換
#
# 概要
#   yamlファイルの定義内容を、properties形式で標準出力します。
#
# 引数
#   yamlファイルパス
#
# 出力
#   環境変数
#     なし
#   標準出力
#     サンプルを参照してください。
#   ファイル
#     なし
#
# サンプル
#   yaml
#     map:
#       key: value1
#       list:
#       - list_value1
#       - list_value2
#
#   properties
#     map_key="value1"
#     map_list_0="list_value1"
#     map_list_1="list_value2"
#
#--------------------------------------------------------------------------------------------------
function yaml2properties() {
  log.func_start_trace "$@"

  local _path_input_yaml="$1"

  local _path_tmp_fields="/tmp/$$_$(basename ${_path_input_yaml}).fields"
  local _path_tmp_values="/tmp/$$_$(basename ${_path_input_yaml}).values"
  local _path_tmp_result="/tmp/$$_$(basename ${_path_input_yaml}).result"

  # 変数名ファイルを生成
  # サンプル
  #   MAP_KEY
  #   MAP_LIST_0
  #   MAP_LIST_1
  # shellcheck disable=SC2002
  cat "${_path_input_yaml}"                                                                        | # yamlファイルから
  ${DIR_BIN_LIB}/yaml2json                                                                         | # jsonに変換
  parsrj.sh -rt -kd_                                                                               | # json -> フィールド形式
  self 1                                                                                           | # 項目名 をselect
  sed -e 's|^_||'                                                                                  | # 行頭の_を除去
  sed -e 's|\[|_|g'                                                                                | # 配列のインデックスを除去
  sed -e 's|\]||g'                                                                                 |
#  tr '[:lower:]' '[:upper:]'                                                                       | # 大文字化
  tee > "${_path_tmp_fields}"

  # 値ファイルを生成
  # サンプル
  #   "value1"
  #   "list_value1"
  #   "list_value2"
  # shellcheck disable=SC2002
  cat "${_path_input_yaml}"                                                                        | # yamlファイルから
  ${DIR_BIN_LIB}/yaml2json                                                                         | # jsonに変換
  parsrj.sh -rt -kd_                                                                               | # json -> フィールド形式
  self 2/NF                                                                                        | # 値 をselect
  xargs -I{} /bin/bash -c "eval 'echo {}'"                                                         | # 環境変数を展開
  sed -e 's|^|"|'                                                                                  | # ダブルクォートで括る
  sed -e 's|$|"|'                                                                                  |
  tee > "${_path_tmp_values}"

  # "="区切りで横方向に連結
  paste -d '=' "${_path_tmp_fields}" "${_path_tmp_values}" > "${_path_tmp_result}"

  # 結果表示
  # shellcheck disable=SC2002
  cat "${_path_tmp_result}" | log.trace
  cat "${_path_tmp_result}"

  # 一時ファイルを削除
  rm -f "${_path_tmp_fields}"
  rm -f "${_path_tmp_values}"
  rm -f "${_path_tmp_result}"

  log.func_end_trace ${EXITCODE_SUCCESS}
}



#--------------------------------------------------------------------------------------------------
# yamlファイルの環境変数展開
#
# 概要
#   yamlファイルの定義内容を、exportした環境変数に設定します。
#
# 引数
#   yamlファイルパス
#
# 出力
#   環境変数
#     サンプルを参照してください。
#   標準出力
#     なし
#   ファイル
#     なし
#
# サンプル
#   yaml
#     map:
#       key: value1
#       list:
#       - list_value1
#       - list_value2
#
#   環境変数
#     map_key="value1"
#     map_list_0="list_value1"
#     map_list_1="list_value2"
#
#--------------------------------------------------------------------------------------------------
function export_yaml() {
  log.func_start_trace "$@"
  local _path_input_yaml="$1"
  local _tmp_path_props="/tmp/export_yaml_$$.properties"

  yaml2properties "${_path_input_yaml}" | sed -e 's|^|export |' > "${_tmp_path_props}"
  source "${_tmp_path_props}"
  rm -f "${_tmp_path_props}"

  log.func_end_trace ${EXITCODE_SUCCESS}
}



#---------------------------------------------------------------------------------------------------
# 動的な環境変数の反映
#
# 概要
#   KEY=VALUE の文字列から、環境変数 KEY (設定値 VALUE) を設定します。
#
# 引数
#   1: 変数定義 KEY=VALUE
#
# 出力
#   環境変数
#     KEY
#   標準出力
#     なし
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function apply_dynamic_env() {
  local _tmp_var="$(echo $1 | cut -d '=' -f 1)"
  local _tmp_value="$(echo $1 | cut -d '=' -f 2)"
  eval ${_tmp_var}=\'${_tmp_value}\'
  # shellcheck disable=SC2163
  export "${_tmp_var}"
}



function processing_time.start() {
  local _key="$1"

  local _filepath_processing_time=$(private.processing_time.get_filepath "${_key}")
  if [[ -f "${_filepath_processing_time}" ]]; then
    log.error "${_filepath_processing_time} is already exist."
    return ${EXITCODE_ERROR}
  fi

  echo -n "$(date '+%Y%m%d%H%M%S')" >"${_filepath_processing_time}"
}

function processing_time.get_start_time() {
  local _key="$1"

  local _filepath_processing_time=$(private.processing_time.get_filepath "${_key}")
  if [[ ! -f "${_filepath_processing_time}" ]]; then
    log.error "${_filepath_processing_time} is not exist. key=${_key}"
    return ${EXITCODE_ERROR}
  fi
  cat "${_filepath_processing_time}"
}

function processing_time.get_lap_time() {
  local _key="$1"

  local _start_time=$(processing_time.get_start_time "${_key}")
  if [[ "${_start_time}x" = "x" ]]; then return ${EXITCODE_ERROR}; fi

  local _now=$(date '+%Y%m%d%H%M%S')
  private.calc_processing_time "${_start_time}" "${_now}"
}

function processing_time.end() {
  local _key="$1"

  processing_time.get_lap_time "${_key}"
  local _retcode=$?
  if [[ ${_retcode} -ne ${EXITCODE_SUCCESS} ]]; then return ${EXITCODE_ERROR}; fi

  local _filepath_processing_time=$(private.processing_time.get_filepath "${_key}")
  rm -f "${_filepath_processing_time}"
}

function private.processing_time.get_filepath() {
  local _key="$1"
  local _DIR_STORE="/tmp/processing_time"
  if [[ ! -d "${_DIR_STORE}" ]]; then mkdir -p "${_DIR_STORE}"; fi
  echo "${_DIR_STORE}/$(echo ${_key//\//_} | _urlencode)"
}

function private.calc_processing_time() {
  local _start_time="$1"
  local _end_time="$2"
  echo "${_start_time} ${_end_time}"                                                               | # 開始・終了時刻(YYYYMMddHHmmss)から
  calclock 1 2 -                                                                                   | # エポックからのミリ秒に変換
  awk '{ print $4 - $2}'                                                                           | # ミリ秒の差分を取得
  calclock -r 1 -                                                                                  | # 差分をYYYYMMddHHmmssに変換
  awk '{
    # 197001ddHHmmss -> d
    day = substr($2, 8, 1)
    # 197001ddHHmmss -> HH
    hour = substr($2, 9, 2)
    # 197001ddHHmmss -> mm
    min = substr($2, 11, 2)
    # 197001ddHHmmss -> ss
    sec = substr($2, 13, 2)
    # 19700101からの相対日付なので、1日減算
    if ( day > 1 ) {
      hour = hour + ( (day - 1) * 24 )
    }
    print hour":"min":"sec
  }'
}

# yyyymmddhhmmss -> yyyy-mm-ddThh:mm:ssZ
function timestamp_to_iso() {
  local _date=$1
  local _zone=$(date '+%z')
  echo "${_date:0:4}-${_date:4:2}-${_date:6:2}T${_date:8:2}:${_date:10:2}:${_date:12:2}${_zone}"
}
