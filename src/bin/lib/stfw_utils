#!/bin/bash
#set -eux
#===================================================================================================
# stfw共通ユーティリティ
#
# 前提
#   ・システム設定を事前に読み込んでいること
#
# 定義リスト
#   stfw.apply_log_level
#   stfw.parse_log_level
#   stfw.get_plugin_path
#   stfw.get_passwd_path
#   stfw.show_passwd
#   stfw.list_files
#   stfw.bulk_exec_scripts
#   stfw.is_in_scenario-root-dir
#   stfw.is_in_scenario-dir
#   stfw.is_in_scenario-bizdate-dir
#   stfw.is_in_scenario-process-dir
#   stfw.process.list
#   stfw.process.get_path
#   stfw.process.is_installed
#   stfw.process.install
#   stfw.get_digdag_version
#   stfw.must_run_on_server
#   stfw.is_run_on_server
#   stfw.set_raw_params
#   stfw.get_raw_params
#   stfw.webhook.async_execute
#
#===================================================================================================
#---------------------------------------------------------------------------------------------------
# ログレベル反映
#
# 概要
#   ログレベル名(error | warn | info | debug | tarace) に合わせて
#   logging_utilsの定数を環境変数に設定します。
#
# 引数
#   1: ログレベル名
#
# 出力
#   環境変数
#     LOGLEVEL
#   標準出力
#     なし
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.apply_log_level() {
  case $1 in
    error)
      export LOGLEVEL="${LOGLEVEL_ERROR}"
      ;;
    warn)
      export LOGLEVEL="${LOGLEVEL_WARN}"
      ;;
    info)
      export LOGLEVEL="${LOGLEVEL_INFO}"
      ;;
    debug)
      export LOGLEVEL="${LOGLEVEL_DEBUG}"
      ;;
    trace)
      export LOGLEVEL="${LOGLEVEL_TRACE}"
      ;;
  esac
}


#---------------------------------------------------------------------------------------------------
# ログレベル定数 -> ログレベル名 の変換
#
# 概要
#   logging_utilsの定数から
#   ログレベル名(error | warn | info | debug | tarace) を返します。
#
# 引数
#   1: ログレベル定数
#
# 出力
#   環境変数
#     なし
#   標準出力
#     ログレベル名
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.parse_log_level() {
  case $1 in
    "${LOGLEVEL_ERROR}")
      echo "error"
      ;;
    "${LOGLEVEL_WARN}")
      echo "warn"
      ;;
    "${LOGLEVEL_INFO}")
      echo "info"
      ;;
    "${LOGLEVEL_DEBUG}")
      echo "debug"
      ;;
    "${LOGLEVEL_TRACE}")
      echo "trace"
      ;;
  esac
}


#---------------------------------------------------------------------------------------------------
# pluginディレクトリ取得
#
# 概要
#   プロジェクトpluginが存在する場合、そのパス
#   組み込みpluginが存在する場合、そのパス
#   pluginが存在しない場合、空文字 を返します。
#
# 引数
#   1: plugin名
#
# 出力
#   環境変数
#     なし
#   標準出力
#     pluginディレクトリ
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.get_plugin_path() {
  local _plugin_name="$1"

  log.func_start_trace "$@"
  local _retcode=${EXITCODE_SUCCESS}
  local _result=""

  # プロジェクトplugin
  if [[ -d "${STFW_PROJ_DIR_PLUGIN}/${_plugin_name}" ]]; then
    _result="${STFW_PROJ_DIR_PLUGIN}/${_plugin_name}"
  fi
  if [[ "$(stfw.is_run_on_server)" = "true" ]]; then
    # digdagでワークフロー実行中の場合、workspaceディレクトリになるので、実ディレクトリを明示
    local _real_proj_plugin_dir="${STFW_PROJ_DIR//\/\.stfw.*$/}/plugins/${_plugin_name}"
    if [[ -d "${_real_proj_plugin_dir}" ]]; then
      _result="${_real_proj_plugin_dir}"
    fi
  fi

  # 組み込みplugin
  if [[ -d "${DIR_PLUGIN}/${_plugin_name}" ]]; then
    _result="${DIR_PLUGIN}/${_plugin_name}"
  fi

  if [[ "${_result}x" = "x" ]]; then
    log.warn "${_plugin_name} is not exist."
    _retcode=${EXITCODE_ERROR}
  else
    log.trace "result: ${_result}"
    echo "${_result}"
  fi

  log.func_end_trace ${_retcode}
  return ${_retcode}
}


#---------------------------------------------------------------------------------------------------
# passwdファイルパス取得
#
# 概要
#   指定ホスト x ユーザ のpasswdファイルパスを返します。
#
# 引数
#   1: host
#   2: user
#
# 出力
#   環境変数
#     なし
#   標準出力
#     passwdファイルパス
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.get_passwd_path() {
  local _host="$1"
  local _user="$2"

  local _dir_passwd="${STFW_PROJ_DIR_CONFIG}/passwd"
  echo "${_dir_passwd}/${_host//:/_}-${_user//:/_}"

  return ${EXITCODE_SUCCESS}
}


#---------------------------------------------------------------------------------------------------
# password取得
#
# 概要
#   指定ホスト x ユーザ のpasswordを返します。
#
# 引数
#   1: host
#   2: user
#
# 出力
#   環境変数
#     なし
#   標準出力
#     password
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.show_passwd() {
  local _host="$1"
  local _user="$2"

  local _path_passwd="$(stfw.get_passwd_path ${_host} ${_user})"
  if [[ ! -f "${_path_passwd}" ]]; then
    log.error "${_path_passwd} is not exist. host: ${_host}, user: ${_user}"
    return ${EXITCODE_ERROR}
  fi

  _decrypt "${PATH_DECRYPT_KEY}" <"${_path_passwd}"
  local _retcode=$?

  return ${_retcode}
}


#---------------------------------------------------------------------------------------------------
# 指定ディレクトリ直下のファイル名リスト
#
# 概要
#   指定ディレクトリ直下の全ファイル名を、文字列の昇順でソートしたリストを返します。
#
# 引数
#   1: スクリプト配置ディレクトリ
#
# 出力
#   環境変数
#     なし
#   標準出力
#     ファイル名リスト
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.list_files() {
  log.func_start_trace "$@"

  local _dir="$1"

  find "${_dir}" -mindepth 1 -maxdepth 1 -follow -type f                                           |
  sed -e "s|${_dir}/||"                                                                            |
  sort

  log.func_end_trace ${EXITCODE_SUCCESS}
  return ${EXITCODE_SUCCESS}
}


#---------------------------------------------------------------------------------------------------
# スクリプトの一括実行
#
# 概要
#   指定ディレクトリ直下の全てのファイルを、スクリプトとみなして一括実行します。
#   スクリプトから0以外のリターンコードが返された場合、後続は実行せずエラー終了します。
#
# 引数
#   1: スクリプト配置ディレクトリ
#
# リターンコード
#   ${EXITCODE_SUCCESS}: 正常終了した場合
#   ${EXITCODE_ERROR}  : エラー発生時
#
# 出力
#   環境変数
#     なし
#   標準出力
#     スクリプトの標準出力&標準エラー
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.bulk_exec_scripts() {
  log.func_start_trace "$@"

  local _dir="$1"
  local _before_dir="$(pwd)"

  log.trace "cd \"${_dir}\""
  cd "${_dir}"

  local _before_IFS="$IFS"
  IFS=$'\n'
  for _cur_file in $(stfw.list_files .); do
    local _exitcode=${EXITCODE_SUCCESS}
    local _cur_retcode=${EXITCODE_SUCCESS}

    local _sect_name="${_dir}/${_cur_file}"
    log.sect_start_info "${_sect_name}"
    ./${_cur_file}
    _cur_retcode=$?
    log.sect_end_info "${_sect_name}" "${_cur_retcode}"

    if [[ ${_cur_retcode} -ne ${EXITCODE_SUCCESS} ]]; then
      _exitcode=${EXITCODE_ERROR}
      break
    fi

  done
  IFS="${_before_IFS}"

  log.trace "cd \"${_before_dir}\""
  cd "${_before_dir}"

  log.func_end_trace ${_exitcode}
  return ${_exitcode}
}


function stfw.is_in_scenario-root-dir() {
  local _check_scenario_root_dirname=$(basename "$(pwd)")
  local _check_file="../${FILENAME_SYSTEM_CONFIG}"
  if [[ "${_check_scenario_root_dirname}" = "scenario" ]] && [[ -f ${_check_file} ]]; then
    echo "true"
  else
    echo "false"
  fi
  return ${EXITCODE_SUCCESS}
}
function stfw.is_in_scenario-dir() {
  local _check_scenario_root_dirname=$(basename "$(cd ..; pwd)")
  local _check_file="../../${FILENAME_SYSTEM_CONFIG}"
  if [[ "${_check_scenario_root_dirname}" = "scenario" ]] && [[ -f ${_check_file} ]]; then
    echo "true"
  else
    echo "false"
  fi
  return ${EXITCODE_SUCCESS}
}
function stfw.is_in_scenario-bizdate-dir() {
  local _check_scenario_root_dirname=$(basename "$(cd ../..; pwd)")
  local _check_file="../../../${FILENAME_SYSTEM_CONFIG}"
  if [[ "${_check_scenario_root_dirname}" = "scenario" ]] && [[ -f ${_check_file} ]]; then
    echo "true"
  else
    echo "false"
  fi
  return ${EXITCODE_SUCCESS}
}
function stfw.is_in_scenario-process-dir() {
  local _check_scenario_root_dirname=$(basename "$(cd ../../..; pwd)")
  local _check_file="../../../../${FILENAME_SYSTEM_CONFIG}"
  if [[ "${_check_scenario_root_dirname}" = "scenario" ]] && [[ -f ${_check_file} ]]; then
    echo "true"
  else
    echo "false"
  fi
  return ${EXITCODE_SUCCESS}
}


#---------------------------------------------------------------------------------------------------
# process一覧
#
# 概要
#   プロジェクト、STFW_HOMEに配置されたprocess名を一覧表示します。
#
# 引数
#   なし
#
# リターンコード
#   ${EXITCODE_SUCCESS}: 正常終了した場合
#   ${EXITCODE_ERROR}  : エラー発生時
#
# 出力
#   環境変数
#     なし
#   標準出力
#     process名
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.process.list() {
  log.func_start_trace "$@"

  # 一時ファイル
  local _tmp_embed_list="/tmp/${FUNCNAME[0]}_$$_embed"
  local _tmp_proj_list="/tmp/${FUNCNAME[0]}_$$_proj"

  # 組込みpluginリスト作成
  local _target_dir="${DIR_PLUGIN}/process"
  find "${_target_dir}" -mindepth 1 -maxdepth 1 -type d                                            | # 直下のディレクトリパスから
  sed -e "s|${_target_dir}/||"                                                                     | # ディレクトリ名に変換
  tee > "${_tmp_embed_list}"
  log.trace "find \"${_target_dir}\" -mindepth 1 -maxdepth 1 -type d"

  # プロジェクトpluginリスト作成
  local _target_dir="${STFW_PROJ_DIR_PLUGIN}/process"
  touch "${_tmp_proj_list}"
  if [[ -d "${_target_dir}" ]]; then
    find "${_target_dir}" -mindepth 1 -maxdepth 1 -type d                                          | # 直下のディレクトリパスから
    sed -e "s|${_target_dir}/||"                                                                   | # ディレクトリ名に変換
    tee > "${_tmp_proj_list}"
    log.trace "find \"${_target_dir}\" -mindepth 1 -maxdepth 1 -type d"
  fi

  # 結果リスト表示
  cat "${_tmp_embed_list}" "${_tmp_proj_list}"                                                     | # 組込み + プロジェクト のリストから
  grep -v "^_"                                                                                     | # 共通処理を除外
  sort                                                                                             | # 一意に絞る
  uniq

  # 一時ファイルを削除
  rm -f "${_tmp_embed_list}"
  rm -f "${_tmp_proj_list}"

  log.func_end_trace ${EXITCODE_SUCCESS}
  return ${EXITCODE_SUCCESS}
}


#---------------------------------------------------------------------------------------------------
# process plugin配置ディレクトリ取得
#
# 概要
#   プロジェクト、STFW_HOMEいづれかに配置されたprocess pluginの内、利用可能なパスを表示します。
#
# 引数
#   1: process名
#
# リターンコード
#   ${EXITCODE_SUCCESS}: 正常終了した場合
#   ${EXITCODE_ERROR}  : エラー発生時
#
# 出力
#   環境変数
#     なし
#   標準出力
#     process plugin配置ディレクトリ: 存在する場合
#     空文字                        : 存在しない場合
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.process.get_path() {
  log.func_start_trace "$@"

  local _retcode=${EXITCODE_SUCCESS}
  stfw.get_plugin_path "process/$1"
  _retcode=$?

  log.func_end_trace ${_retcode}
  return ${_retcode}
}


#---------------------------------------------------------------------------------------------------
# process pluginインストール済み確認
#
# 概要
#   プロジェクト、STFW_HOMEいづれかに配置されたprocess pluginのis_installedスクリプトを実行します。
#
# 引数
#   1: process plugin path
#
# リターンコード
#   ${EXITCODE_SUCCESS}: インストール済みの場合
#   ${EXITCODE_ERROR}  : その他の場合
#
# 出力
#   環境変数
#     なし
#   標準出力
#     true : インストール済みの場合
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.process.is_installed() {
  log.func_start_trace "$@"
  local _retcode=${EXITCODE_SUCCESS}

  local _plugin_path="$1"

  if [[ ! -d "${_plugin_path}" ]]; then
    log.error "process: ${_plugin_path} is not exist."
    return ${EXITCODE_ERROR}
  fi

  "${_plugin_path}/bin/install/is_installed"
  _retcode=$?

  log.func_end_trace ${_retcode}
  return ${_retcode}
}


#---------------------------------------------------------------------------------------------------
# process pluginインストール
#
# 概要
#   プロジェクト、STFW_HOMEいづれかに配置されたprocess pluginのinstallスクリプトを実行します。
#
# 引数
#   1: process plugin path
#
# リターンコード
#   ${EXITCODE_SUCCESS}: 正常終了した場合
#   ${EXITCODE_ERROR}  : エラー発生時
#
# 出力
#   環境変数
#     なし
#   標準出力
#     なし
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.process.install() {
  log.func_start_trace "$@"
  local _retcode=${EXITCODE_SUCCESS}

  local _plugin_path="$1"

  local _is_installed=$(stfw.process.is_installed "${_plugin_path}")
  if [[ "${_is_installed}" = "true" ]]; then
    log.info "${_plugin_path} is already installed."
    return ${EXITCODE_SUCCESS}
  fi

  "${_plugin_path}/bin/install/install"
  _retcode=$?

  log.func_end_trace ${_retcode}
  return ${_retcode}
}

#---------------------------------------------------------------------------------------------------
# digdagバージョン取得
#
# 概要
#   digdagのバージョンを取得します。
#
# 引数
#   なし
#
# 出力
#   環境変数
#     なし
#   標準出力
#     digdagバージョン
#   ファイル
#     ${STFW_PROJ_DIR_DATA}/digdag_version
#
#---------------------------------------------------------------------------------------------------
function stfw.get_digdag_version() {
  if [[ ! -f "${STFW_PROJ_DIR_DATA}/digdag_version" ]]; then
    ${PATH_DIGDAG} version 2> /dev/null | \
      grep Server | \
      cut -d ' ' -f 3 > ${STFW_PROJ_DIR_DATA}/digdag_version
  fi
  cat ${STFW_PROJ_DIR_DATA}/digdag_version
}

#---------------------------------------------------------------------------------------------------
# シナリオ実行中チェック
#
# 概要
#   シナリオ実行中ではない場合、エラー終了します。
#
# 引数
#   なし
#
# 出力
#   環境変数
#     なし
#   標準出力
#     なし
#   ファイル
#     なし
#
#---------------------------------------------------------------------------------------------------
function stfw.must_run_on_server() {
  if [[ "$(stfw.is_run_on_server)" = "true" ]]; then return ${EXITCODE_SUCCESS}; fi

  log.error "must run on server."
  exit ${EXITCODE_ERROR}
}

function stfw.is_run_on_server() {
  if [[ "${STFW_PROJ_DIR}" = "${STFW_PROJ_DIR//\/\.stfw//}" ]]; then
    echo "false"
    return ${EXITCODE_SUCCESS}
  fi

  echo "true"
  return ${EXITCODE_SUCCESS}
}

#---------------------------------------------------------------------------------------------------
# stfw起動パラメータ保存
#
# 概要
#   stfwコマンドの実行時パラメータを保存します。
#
# 引数
#   1: digdag project dir
#
# 出力
#   環境変数
#     なし
#   標準出力
#     なし
#   ファイル
#     {digdag_project_dir}/params
#
#---------------------------------------------------------------------------------------------------
function stfw.set_raw_params() {
  local _path_params="${1:?}/params"
  echo "${stfw_raw_params:?}" >"${_path_params}"
}

#---------------------------------------------------------------------------------------------------
# stfw起動パラメータ取得
#
# 概要
#   stfwコマンドの実行時パラメータを取得します。
#
# 引数
#   なし
#
# 出力
#   環境変数
#     なし
#   標準出力
#     stfwコマンドのパラメータ
#   ファイル
#     ${STFW_PROJ_DIR_DATA}/params
#
#---------------------------------------------------------------------------------------------------
function stfw.get_raw_params() {
  stfw.must_run_on_server

  local _path_params="${STFW_PROJ_DIR}/params"
  if [[ ! -f "${_path_params}" ]]; then
    log.error "${_path_params} is not exist."
    exit ${EXITCODE_ERROR}
  fi

  cat "${_path_params}"
}


function stfw.webhook.async_execute() {
  local _key="$1"
  local _type="$2"
  local _event="$3"
  local _relpath_plugin="$4"

  # ステータスチェック
  local _status="Success"
  if [[ "${_event}" = "start" ]]; then
    _status="Started"
    if [[ "${stfw_webhooks_on_start:?}" != "true" ]]; then return ${EXITCODE_SUCCESS}; fi

  else
    # check status from digdag
    # shellcheck disable=SC2154
    if [[ "${stfw_run_status}" = "error" ]]; then
      _status="Error"
      if [[ "${stfw_webhooks_on_error:?}" != "true" ]]; then return ${EXITCODE_SUCCESS}; fi
    else
      if [[ "${stfw_webhooks_on_success:?}" != "true" ]]; then return ${EXITCODE_SUCCESS}; fi
      # process スクリプトの結果判定
      local _script_exit=${EXITCODE_SUCCESS}
      if [[ -f "${STFW_PROJ_DIR}/tmp_stfw_process_scripts.exitcode" ]]; then
        _script_exit=$(cat "${STFW_PROJ_DIR}/tmp_stfw_process_scripts.exitcode")
        rm "${STFW_PROJ_DIR}/tmp_stfw_process_scripts.exitcode"
      fi
      if [[ ${_script_exit} -ne ${EXITCODE_SUCCESS} ]]; then
        _status="Error"
      fi
    fi
  fi

  readonly webhook_type=${_type}
  readonly webhook_status=${_status}

  readonly stfw_raw_params=$(stfw.get_raw_params)
  readonly STFW_SERVER_VERSION=$(stfw.get_digdag_version)

  # 開始・終了時間計算
  local _filepath_processing_time=$(private.processing_time.get_filepath "${_key}")
  local _start_time=$(cat "${_filepath_processing_time}")
  readonly webhook_start_time=$(timestamp_to_iso ${_start_time})

  local webhook_end_time=
  local webhook_processing_time=
  if [[ "${_event}" != "start" ]]; then
    local _end_time=$(date '+%Y%m%d%H%M%S')

    readonly webhook_end_time=$(timestamp_to_iso ${_end_time})
    readonly webhook_processing_time=$(private.calc_processing_time ${_start_time} ${_end_time})
  fi

  # webhookに必要な設定をまとめる
  local _configs="${DIR_CONFIG}/webhook/payload.yml"
  case ${_type} in
    run)
      _configs="${_configs} ${DIR_CONFIG}/webhook/run.yml"
      ;;
    scenario)
      _configs="${_configs} ${DIR_CONFIG}/webhook/run.yml"
      _configs="${_configs} ${DIR_CONFIG}/webhook/scenario.yml"
      ;;
    bizdate)
      _configs="${_configs} ${DIR_CONFIG}/webhook/run.yml"
      _configs="${_configs} ${DIR_CONFIG}/webhook/scenario.yml"
      _configs="${_configs} ${DIR_CONFIG}/webhook/bizdate.yml"
      ;;
    process)
      _configs="${_configs} ${DIR_CONFIG}/webhook/run.yml"
      _configs="${_configs} ${DIR_CONFIG}/webhook/scenario.yml"
      _configs="${_configs} ${DIR_CONFIG}/webhook/bizdate.yml"
      _configs="${_configs} ${DIR_CONFIG}/webhook/process.yml"
      ;;
    *)
      ;;
  esac

  local _tmp_yml_file="/tmp/stfw_webhook_${_type}_${_event}_$$.yml"

  # 複数ファイルをcatで合成しつつ、変数展開、jsonへ変換
  # shellcheck disable=SC2002
  cat ${_configs} | grep -v "^#" |
  while IFS= read -r _line; do
    eval "echo \"${_line}\""
  done >"${_tmp_yml_file}"

  # プロセスの場合、プラグイン分を合成
  if [[ ${_type} = "process" ]]; then
    (
      # サブシェルとして動かして、カレントディレクトリの移動を意識しなくて良くしています。
      cd "${stfw_process_dir:?}"
      local _plugin_dir=$(stfw.get_plugin_path "${_relpath_plugin}")
      "${_plugin_dir}/bin/webhook/get_${_event}_content" | grep -v "^#" >>"${_tmp_yml_file}"
      local _retcode=${PIPESTATUS[0]}

      if [[ ${_retcode} -ne ${EXITCODE_SUCCESS} ]]; then
        log.error "get_${_event}_content is failed. process_relpath_plugin=${_relpath_plugin}"
      fi
    )
  fi

  # 非同期実行
  private.stfw.webhook_async_execute "${_tmp_yml_file}" &
}

function private.stfw.webhook_async_execute() {
  local _tmp_yml_file="$1"
  local _tmp_json_file="${_tmp_yml_file}.json"

  # yml -> json変換
  "${DIR_BIN_LIB}/yaml2json" "${_tmp_yml_file}" >"${_tmp_json_file}"
  rm "${_tmp_yml_file}"

  printenv | grep stfw_webhooks_urls_ | cut -d "=" -f 2 |
  while read -r _webhooks_url; do
    curl                                                                                           \
      --silent                                                                                     \
      --show-error                                                                                 \
      --request POST                                                                               \
      --data-binary "@${_tmp_json_file}"                                                           \
      --header "Content-type: application/json"                                                    \
      "${_webhooks_url}" | log.debug
    _retcode=${PIPESTATUS[0]}

    if [[ ${_retcode} -eq ${EXITCODE_SUCCESS} ]]; then
      log.info "webhook post to ${_webhooks_url}"
    else
      log.warn "webhook post failed. target:${_webhooks_url}, retcode:${_retcode}"
    fi
  done

  rm "${_tmp_json_file}"
}
